// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#ifndef PROTOBUF_mesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2eproto();
void protobuf_AssignDesc_mesos_2eproto();
void protobuf_ShutdownFile_mesos_2eproto();

class FrameworkID;
class OfferID;
class SlaveID;
class TaskID;
class ExecutorID;
class FrameworkInfo;
class CommandInfo;
class CommandInfo_URI;
class ExecutorInfo;
class MasterInfo;
class SlaveInfo;
class Value;
class Value_Scalar;
class Value_Range;
class Value_Ranges;
class Value_Set;
class Value_Text;
class Attribute;
class Resource;
class ResourceStatistics;
class ResourceUsage;
class Request;
class Offer;
class TaskInfo;
class TaskStatus;
class Filters;
class Environment;
class Environment_Variable;
class Parameter;
class Parameters;

enum Value_Type {
  Value_Type_SCALAR = 0,
  Value_Type_RANGES = 1,
  Value_Type_SET = 2,
  Value_Type_TEXT = 3
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_SCALAR;
const Value_Type Value_Type_Type_MAX = Value_Type_TEXT;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
enum Status {
  DRIVER_NOT_STARTED = 1,
  DRIVER_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = DRIVER_NOT_STARTED;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum TaskState {
  TASK_STAGING = 6,
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_LOST = 5
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_STAGING;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message {
 public:
  FrameworkID();
  virtual ~FrameworkID();
  
  FrameworkID(const FrameworkID& from);
  
  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();
  
  void Swap(FrameworkID* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkID* default_instance_;
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message {
 public:
  OfferID();
  virtual ~OfferID();
  
  OfferID(const OfferID& from);
  
  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();
  
  void Swap(OfferID* other);
  
  // implements Message ----------------------------------------------
  
  OfferID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static OfferID* default_instance_;
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message {
 public:
  SlaveID();
  virtual ~SlaveID();
  
  SlaveID(const SlaveID& from);
  
  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();
  
  void Swap(SlaveID* other);
  
  // implements Message ----------------------------------------------
  
  SlaveID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static SlaveID* default_instance_;
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message {
 public:
  TaskID();
  virtual ~TaskID();
  
  TaskID(const TaskID& from);
  
  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();
  
  void Swap(TaskID* other);
  
  // implements Message ----------------------------------------------
  
  TaskID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static TaskID* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message {
 public:
  ExecutorID();
  virtual ~ExecutorID();
  
  ExecutorID(const ExecutorID& from);
  
  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();
  
  void Swap(ExecutorID* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static ExecutorID* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();
  
  FrameworkInfo(const FrameworkInfo& from);
  
  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();
  
  void Swap(FrameworkInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .mesos.FrameworkID id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& id() const;
  inline ::mesos::FrameworkID* mutable_id();
  inline ::mesos::FrameworkID* release_id();
  
  // optional double failover_timeout = 4 [default = 0];
  inline bool has_failover_timeout() const;
  inline void clear_failover_timeout();
  static const int kFailoverTimeoutFieldNumber = 4;
  inline double failover_timeout() const;
  inline void set_failover_timeout(double value);
  
  // optional bool checkpoint = 5 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 5;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);
  
  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  
  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_failover_timeout();
  inline void clear_has_failover_timeout();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_role();
  inline void clear_has_role();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_;
  ::std::string* name_;
  ::mesos::FrameworkID* id_;
  double failover_timeout_;
  ::std::string* role_;
  static const ::std::string _default_role_;
  bool checkpoint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_URI : public ::google::protobuf::Message {
 public:
  CommandInfo_URI();
  virtual ~CommandInfo_URI();
  
  CommandInfo_URI(const CommandInfo_URI& from);
  
  inline CommandInfo_URI& operator=(const CommandInfo_URI& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_URI& default_instance();
  
  void Swap(CommandInfo_URI* other);
  
  // implements Message ----------------------------------------------
  
  CommandInfo_URI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_URI& from);
  void MergeFrom(const CommandInfo_URI& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional bool executable = 2;
  inline bool has_executable() const;
  inline void clear_executable();
  static const int kExecutableFieldNumber = 2;
  inline bool executable() const;
  inline void set_executable(bool value);
  
  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.URI)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_executable();
  inline void clear_has_executable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  bool executable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static CommandInfo_URI* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo : public ::google::protobuf::Message {
 public:
  CommandInfo();
  virtual ~CommandInfo();
  
  CommandInfo(const CommandInfo& from);
  
  inline CommandInfo& operator=(const CommandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo& default_instance();
  
  void Swap(CommandInfo* other);
  
  // implements Message ----------------------------------------------
  
  CommandInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo& from);
  void MergeFrom(const CommandInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CommandInfo_URI URI;
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.CommandInfo.URI uris = 1;
  inline int uris_size() const;
  inline void clear_uris();
  static const int kUrisFieldNumber = 1;
  inline const ::mesos::CommandInfo_URI& uris(int index) const;
  inline ::mesos::CommandInfo_URI* mutable_uris(int index);
  inline ::mesos::CommandInfo_URI* add_uris();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
      uris() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
      mutable_uris();
  
  // optional .mesos.Environment environment = 2;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  inline const ::mesos::Environment& environment() const;
  inline ::mesos::Environment* mutable_environment();
  inline ::mesos::Environment* release_environment();
  
  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.CommandInfo)
 private:
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI > uris_;
  ::mesos::Environment* environment_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static CommandInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();
  
  ExecutorInfo(const ExecutorInfo& from);
  
  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();
  
  void Swap(ExecutorInfo* other);
  
  // implements Message ----------------------------------------------
  
  ExecutorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  
  // optional .mesos.FrameworkID framework_id = 8;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 8;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  
  // required .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  
  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // optional string name = 9;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 9;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string source = 10;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 10;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  
  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::CommandInfo* command_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* name_;
  ::std::string* source_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static ExecutorInfo* default_instance_;
};
// -------------------------------------------------------------------

class MasterInfo : public ::google::protobuf::Message {
 public:
  MasterInfo();
  virtual ~MasterInfo();
  
  MasterInfo(const MasterInfo& from);
  
  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo& default_instance();
  
  void Swap(MasterInfo* other);
  
  // implements Message ----------------------------------------------
  
  MasterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);
  
  // required uint32 port = 3 [default = 5050];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:mesos.MasterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static MasterInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();
  
  SlaveInfo(const SlaveInfo& from);
  
  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();
  
  void Swap(SlaveInfo* other);
  
  // implements Message ----------------------------------------------
  
  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // optional int32 port = 8 [default = 5051];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // required string webui_hostname = 2;
  inline bool has_webui_hostname() const;
  inline void clear_webui_hostname();
  static const int kWebuiHostnameFieldNumber = 2;
  inline const ::std::string& webui_hostname() const;
  inline void set_webui_hostname(const ::std::string& value);
  inline void set_webui_hostname(const char* value);
  inline void set_webui_hostname(const char* value, size_t size);
  inline ::std::string* mutable_webui_hostname();
  inline ::std::string* release_webui_hostname();
  
  // optional int32 webui_port = 4 [default = 8081];
  inline bool has_webui_port() const;
  inline void clear_webui_port();
  static const int kWebuiPortFieldNumber = 4;
  inline ::google::protobuf::int32 webui_port() const;
  inline void set_webui_port(::google::protobuf::int32 value);
  
  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // repeated .mesos.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();
  
  // optional .mesos.SlaveID id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::mesos::SlaveID& id() const;
  inline ::mesos::SlaveID* mutable_id();
  inline ::mesos::SlaveID* release_id();
  
  // optional bool checkpoint = 7 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);
  
  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_webui_hostname();
  inline void clear_has_webui_hostname();
  inline void set_has_webui_port();
  inline void clear_has_webui_port();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hostname_;
  ::std::string* webui_hostname_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 webui_port_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::mesos::SlaveID* id_;
  bool checkpoint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class Value_Scalar : public ::google::protobuf::Message {
 public:
  Value_Scalar();
  virtual ~Value_Scalar();
  
  Value_Scalar(const Value_Scalar& from);
  
  inline Value_Scalar& operator=(const Value_Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Scalar& default_instance();
  
  void Swap(Value_Scalar* other);
  
  // implements Message ----------------------------------------------
  
  Value_Scalar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Scalar& from);
  void MergeFrom(const Value_Scalar& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);
  
  // @@protoc_insertion_point(class_scope:mesos.Value.Scalar)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value_Scalar* default_instance_;
};
// -------------------------------------------------------------------

class Value_Range : public ::google::protobuf::Message {
 public:
  Value_Range();
  virtual ~Value_Range();
  
  Value_Range(const Value_Range& from);
  
  inline Value_Range& operator=(const Value_Range& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Range& default_instance();
  
  void Swap(Value_Range* other);
  
  // implements Message ----------------------------------------------
  
  Value_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Range& from);
  void MergeFrom(const Value_Range& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);
  
  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:mesos.Value.Range)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value_Range* default_instance_;
};
// -------------------------------------------------------------------

class Value_Ranges : public ::google::protobuf::Message {
 public:
  Value_Ranges();
  virtual ~Value_Ranges();
  
  Value_Ranges(const Value_Ranges& from);
  
  inline Value_Ranges& operator=(const Value_Ranges& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Ranges& default_instance();
  
  void Swap(Value_Ranges* other);
  
  // implements Message ----------------------------------------------
  
  Value_Ranges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Ranges& from);
  void MergeFrom(const Value_Ranges& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Value.Range range = 1;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::mesos::Value_Range& range(int index) const;
  inline ::mesos::Value_Range* mutable_range(int index);
  inline ::mesos::Value_Range* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
      mutable_range();
  
  // @@protoc_insertion_point(class_scope:mesos.Value.Ranges)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range > range_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value_Ranges* default_instance_;
};
// -------------------------------------------------------------------

class Value_Set : public ::google::protobuf::Message {
 public:
  Value_Set();
  virtual ~Value_Set();
  
  Value_Set(const Value_Set& from);
  
  inline Value_Set& operator=(const Value_Set& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Set& default_instance();
  
  void Swap(Value_Set* other);
  
  // implements Message ----------------------------------------------
  
  Value_Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Set& from);
  void MergeFrom(const Value_Set& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item(int index) const;
  inline ::std::string* mutable_item(int index);
  inline void set_item(int index, const ::std::string& value);
  inline void set_item(int index, const char* value);
  inline void set_item(int index, const char* value, size_t size);
  inline ::std::string* add_item();
  inline void add_item(const ::std::string& value);
  inline void add_item(const char* value);
  inline void add_item(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();
  
  // @@protoc_insertion_point(class_scope:mesos.Value.Set)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> item_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value_Set* default_instance_;
};
// -------------------------------------------------------------------

class Value_Text : public ::google::protobuf::Message {
 public:
  Value_Text();
  virtual ~Value_Text();
  
  Value_Text(const Value_Text& from);
  
  inline Value_Text& operator=(const Value_Text& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Text& default_instance();
  
  void Swap(Value_Text* other);
  
  // implements Message ----------------------------------------------
  
  Value_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Text& from);
  void MergeFrom(const Value_Text& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.Value.Text)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value_Text* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();
  
  Value(const Value& from);
  
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();
  
  void Swap(Value* other);
  
  // implements Message ----------------------------------------------
  
  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Value_Scalar Scalar;
  typedef Value_Range Range;
  typedef Value_Ranges Ranges;
  typedef Value_Set Set;
  typedef Value_Text Text;
  
  typedef Value_Type Type;
  static const Type SCALAR = Value_Type_SCALAR;
  static const Type RANGES = Value_Type_RANGES;
  static const Type SET = Value_Type_SET;
  static const Type TEXT = Value_Type_TEXT;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .mesos.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);
  
  // optional .mesos.Value.Scalar scalar = 2;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 2;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  
  // optional .mesos.Value.Ranges ranges = 3;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 3;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  
  // optional .mesos.Value.Set set = 4;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 4;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  
  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  
  // @@protoc_insertion_point(class_scope:mesos.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();
  
  Attribute(const Attribute& from);
  
  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();
  
  void Swap(Attribute* other);
  
  // implements Message ----------------------------------------------
  
  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);
  
  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  
  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  
  // optional .mesos.Value.Set set = 6;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 6;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  
  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  
  // @@protoc_insertion_point(class_scope:mesos.Attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();
  
  Resource(const Resource& from);
  
  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();
  
  void Swap(Resource* other);
  
  // implements Message ----------------------------------------------
  
  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);
  
  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  
  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  
  // optional .mesos.Value.Set set = 5;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 5;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  
  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class ResourceStatistics : public ::google::protobuf::Message {
 public:
  ResourceStatistics();
  virtual ~ResourceStatistics();
  
  ResourceStatistics(const ResourceStatistics& from);
  
  inline ResourceStatistics& operator=(const ResourceStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceStatistics& default_instance();
  
  void Swap(ResourceStatistics* other);
  
  // implements Message ----------------------------------------------
  
  ResourceStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceStatistics& from);
  void MergeFrom(const ResourceStatistics& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // optional double cpus_user_time_secs = 2;
  inline bool has_cpus_user_time_secs() const;
  inline void clear_cpus_user_time_secs();
  static const int kCpusUserTimeSecsFieldNumber = 2;
  inline double cpus_user_time_secs() const;
  inline void set_cpus_user_time_secs(double value);
  
  // optional double cpus_system_time_secs = 3;
  inline bool has_cpus_system_time_secs() const;
  inline void clear_cpus_system_time_secs();
  static const int kCpusSystemTimeSecsFieldNumber = 3;
  inline double cpus_system_time_secs() const;
  inline void set_cpus_system_time_secs(double value);
  
  // required double cpus_limit = 4;
  inline bool has_cpus_limit() const;
  inline void clear_cpus_limit();
  static const int kCpusLimitFieldNumber = 4;
  inline double cpus_limit() const;
  inline void set_cpus_limit(double value);
  
  // optional uint64 mem_rss_bytes = 5;
  inline bool has_mem_rss_bytes() const;
  inline void clear_mem_rss_bytes();
  static const int kMemRssBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 mem_rss_bytes() const;
  inline void set_mem_rss_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 mem_limit_bytes = 6;
  inline bool has_mem_limit_bytes() const;
  inline void clear_mem_limit_bytes();
  static const int kMemLimitBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 mem_limit_bytes() const;
  inline void set_mem_limit_bytes(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:mesos.ResourceStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_cpus_user_time_secs();
  inline void clear_has_cpus_user_time_secs();
  inline void set_has_cpus_system_time_secs();
  inline void clear_has_cpus_system_time_secs();
  inline void set_has_cpus_limit();
  inline void clear_has_cpus_limit();
  inline void set_has_mem_rss_bytes();
  inline void clear_has_mem_rss_bytes();
  inline void set_has_mem_limit_bytes();
  inline void clear_has_mem_limit_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double timestamp_;
  double cpus_user_time_secs_;
  double cpus_system_time_secs_;
  double cpus_limit_;
  ::google::protobuf::uint64 mem_rss_bytes_;
  ::google::protobuf::uint64 mem_limit_bytes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceStatistics* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage : public ::google::protobuf::Message {
 public:
  ResourceUsage();
  virtual ~ResourceUsage();
  
  ResourceUsage(const ResourceUsage& from);
  
  inline ResourceUsage& operator=(const ResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage& default_instance();
  
  void Swap(ResourceUsage* other);
  
  // implements Message ----------------------------------------------
  
  ResourceUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage& from);
  void MergeFrom(const ResourceUsage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  
  // optional .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  
  // optional string executor_name = 4;
  inline bool has_executor_name() const;
  inline void clear_executor_name();
  static const int kExecutorNameFieldNumber = 4;
  inline const ::std::string& executor_name() const;
  inline void set_executor_name(const ::std::string& value);
  inline void set_executor_name(const char* value);
  inline void set_executor_name(const char* value, size_t size);
  inline ::std::string* mutable_executor_name();
  inline ::std::string* release_executor_name();
  
  // optional .mesos.TaskID task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  
  // optional .mesos.ResourceStatistics statistics = 6;
  inline bool has_statistics() const;
  inline void clear_statistics();
  static const int kStatisticsFieldNumber = 6;
  inline const ::mesos::ResourceStatistics& statistics() const;
  inline ::mesos::ResourceStatistics* mutable_statistics();
  inline ::mesos::ResourceStatistics* release_statistics();
  
  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_executor_name();
  inline void clear_has_executor_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_statistics();
  inline void clear_has_statistics();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* executor_name_;
  ::mesos::TaskID* task_id_;
  ::mesos::ResourceStatistics* statistics_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceUsage* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  
  // repeated .mesos.Resource resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // @@protoc_insertion_point(class_scope:mesos.Request)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();
  
  Offer(const Offer& from);
  
  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();
  
  void Swap(Offer* other);
  
  // implements Message ----------------------------------------------
  
  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  inline ::mesos::OfferID* release_id();
  
  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  
  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  
  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // repeated .mesos.Attribute attributes = 7;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();
  
  // repeated .mesos.ExecutorID executor_ids = 6;
  inline int executor_ids_size() const;
  inline void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  inline const ::mesos::ExecutorID& executor_ids(int index) const;
  inline ::mesos::ExecutorID* mutable_executor_ids(int index);
  inline ::mesos::ExecutorID* add_executor_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();
  
  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message {
 public:
  TaskInfo();
  virtual ~TaskInfo();
  
  TaskInfo(const TaskInfo& from);
  
  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();
  
  void Swap(TaskInfo* other);
  
  // implements Message ----------------------------------------------
  
  TaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  
  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  
  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  
  // optional .mesos.ExecutorInfo executor = 5;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 5;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  inline ::mesos::ExecutorInfo* release_executor();
  
  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  
  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor();
  inline void clear_has_executor();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::CommandInfo* command_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();
  
  TaskStatus(const TaskStatus& from);
  
  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();
  
  void Swap(TaskStatus* other);
  
  // implements Message ----------------------------------------------
  
  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  
  // required .mesos.TaskState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline mesos::TaskState state() const;
  inline void set_state(mesos::TaskState value);
  
  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mesos::TaskID* task_id_;
  ::std::string* message_;
  ::std::string* data_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message {
 public:
  Filters();
  virtual ~Filters();
  
  Filters(const Filters& from);
  
  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();
  
  void Swap(Filters* other);
  
  // implements Message ----------------------------------------------
  
  Filters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double refuse_seconds = 1 [default = 5];
  inline bool has_refuse_seconds() const;
  inline void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  inline double refuse_seconds() const;
  inline void set_refuse_seconds(double value);
  
  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  inline void set_has_refuse_seconds();
  inline void clear_has_refuse_seconds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double refuse_seconds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Filters* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Variable : public ::google::protobuf::Message {
 public:
  Environment_Variable();
  virtual ~Environment_Variable();
  
  Environment_Variable(const Environment_Variable& from);
  
  inline Environment_Variable& operator=(const Environment_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Variable& default_instance();
  
  void Swap(Environment_Variable* other);
  
  // implements Message ----------------------------------------------
  
  Environment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Variable& from);
  void MergeFrom(const Environment_Variable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.Environment.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Environment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();
  
  Environment(const Environment& from);
  
  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();
  
  void Swap(Environment* other);
  
  // implements Message ----------------------------------------------
  
  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Environment_Variable Variable;
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Environment.Variable variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::mesos::Environment_Variable& variables(int index) const;
  inline ::mesos::Environment_Variable* mutable_variables(int index);
  inline ::mesos::Environment_Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
      mutable_variables();
  
  // @@protoc_insertion_point(class_scope:mesos.Environment)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable > variables_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();
  
  Parameter(const Parameter& from);
  
  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();
  
  void Swap(Parameter* other);
  
  // implements Message ----------------------------------------------
  
  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:mesos.Parameter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message {
 public:
  Parameters();
  virtual ~Parameters();
  
  Parameters(const Parameters& from);
  
  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();
  
  void Swap(Parameters* other);
  
  // implements Message ----------------------------------------------
  
  Parameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mesos.Parameter parameter = 1;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::mesos::Parameter& parameter(int index) const;
  inline ::mesos::Parameter* mutable_parameter(int index);
  inline ::mesos::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameter();
  
  // @@protoc_insertion_point(class_scope:mesos.Parameters)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameter_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();
  
  void InitAsDefaultInstance();
  static Parameters* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FrameworkID::value() const {
  return *value_;
}
inline void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* FrameworkID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OfferID::value() const {
  return *value_;
}
inline void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OfferID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SlaveID::value() const {
  return *value_;
}
inline void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SlaveID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TaskID::value() const {
  return *value_;
}
inline void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TaskID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ExecutorID::value() const {
  return *value_;
}
inline void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ExecutorID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& FrameworkInfo::user() const {
  return *user_;
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* FrameworkInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FrameworkInfo::name() const {
  return *name_;
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FrameworkInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .mesos.FrameworkID id = 3;
inline bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
  clear_has_id();
}
inline const ::mesos::FrameworkID& FrameworkInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::FrameworkID;
  return id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::release_id() {
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}

// optional double failover_timeout = 4 [default = 0];
inline bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
inline double FrameworkInfo::failover_timeout() const {
  return failover_timeout_;
}
inline void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
}

// optional bool checkpoint = 5 [default = false];
inline bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool FrameworkInfo::checkpoint() const {
  return checkpoint_;
}
inline void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// optional string role = 6 [default = "*"];
inline bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameworkInfo::clear_role() {
  if (role_ != &_default_role_) {
    role_->assign(_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& FrameworkInfo::role() const {
  return *role_;
}
inline void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  if (role_ == &_default_role_) {
    role_ = new ::std::string(_default_role_);
  }
  return role_;
}
inline ::std::string* FrameworkInfo::release_role() {
  clear_has_role();
  if (role_ == &_default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&_default_role_);
    return temp;
  }
}

// -------------------------------------------------------------------

// CommandInfo_URI

// required string value = 1;
inline bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_URI::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo_URI::value() const {
  return *value_;
}
inline void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo_URI::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool executable = 2;
inline bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
inline bool CommandInfo_URI::executable() const {
  return executable_;
}
inline void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
}

// -------------------------------------------------------------------

// CommandInfo

// repeated .mesos.CommandInfo.URI uris = 1;
inline int CommandInfo::uris_size() const {
  return uris_.size();
}
inline void CommandInfo::clear_uris() {
  uris_.Clear();
}
inline const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  return uris_.Get(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  return uris_.Mutable(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  return uris_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  return uris_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  return &uris_;
}

// optional .mesos.Environment environment = 2;
inline bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& CommandInfo::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::mesos::Environment;
  return environment_;
}
inline ::mesos::Environment* CommandInfo::release_environment() {
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}

// required string value = 3;
inline bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo::value() const {
  return *value_;
}
inline void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExecutorInfo

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}

// optional .mesos.FrameworkID framework_id = 8;
inline bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}

// required .mesos.CommandInfo command = 7;
inline bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ExecutorInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  return &resources_;
}

// optional string name = 9;
inline bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutorInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExecutorInfo::name() const {
  return *name_;
}
inline void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExecutorInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string source = 10;
inline bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutorInfo::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& ExecutorInfo::source() const {
  return *source_;
}
inline void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* ExecutorInfo::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutorInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ExecutorInfo::data() const {
  return *data_;
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ExecutorInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MasterInfo

// required string id = 1;
inline bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MasterInfo::id() const {
  return *id_;
}
inline void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MasterInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 ip = 2;
inline bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 MasterInfo::ip() const {
  return ip_;
}
inline void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 3 [default = 5050];
inline bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MasterInfo::port() const {
  return port_;
}
inline void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& SlaveInfo::hostname() const {
  return *hostname_;
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* SlaveInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 port = 8 [default = 5051];
inline bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
inline ::google::protobuf::int32 SlaveInfo::port() const {
  return port_;
}
inline void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string webui_hostname = 2;
inline bool SlaveInfo::has_webui_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveInfo::set_has_webui_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveInfo::clear_has_webui_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveInfo::clear_webui_hostname() {
  if (webui_hostname_ != &::google::protobuf::internal::kEmptyString) {
    webui_hostname_->clear();
  }
  clear_has_webui_hostname();
}
inline const ::std::string& SlaveInfo::webui_hostname() const {
  return *webui_hostname_;
}
inline void SlaveInfo::set_webui_hostname(const ::std::string& value) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(value);
}
inline void SlaveInfo::set_webui_hostname(const char* value) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(value);
}
inline void SlaveInfo::set_webui_hostname(const char* value, size_t size) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_webui_hostname() {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  return webui_hostname_;
}
inline ::std::string* SlaveInfo::release_webui_hostname() {
  clear_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webui_hostname_;
    webui_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 webui_port = 4 [default = 8081];
inline bool SlaveInfo::has_webui_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveInfo::set_has_webui_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveInfo::clear_has_webui_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveInfo::clear_webui_port() {
  webui_port_ = 8081;
  clear_has_webui_port();
}
inline ::google::protobuf::int32 SlaveInfo::webui_port() const {
  return webui_port_;
}
inline void SlaveInfo::set_webui_port(::google::protobuf::int32 value) {
  set_has_webui_port();
  webui_port_ = value;
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 5;
inline int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
inline void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* SlaveInfo::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  return &attributes_;
}

// optional .mesos.SlaveID id = 6;
inline bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::SlaveID::Clear();
  clear_has_id();
}
inline const ::mesos::SlaveID& SlaveInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::SlaveID;
  return id_;
}
inline ::mesos::SlaveID* SlaveInfo::release_id() {
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}

// optional bool checkpoint = 7 [default = false];
inline bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool SlaveInfo::checkpoint() const {
  return checkpoint_;
}
inline void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// -------------------------------------------------------------------

// Value_Scalar

// required double value = 1;
inline bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Value_Scalar::value() const {
  return value_;
}
inline void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
inline bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Value_Range::begin() const {
  return begin_;
}
inline void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
}

// required uint64 end = 2;
inline bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Value_Range::end() const {
  return end_;
}
inline void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
inline int Value_Ranges::range_size() const {
  return range_.size();
}
inline void Value_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  return range_.Get(index);
}
inline ::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  return range_.Mutable(index);
}
inline ::mesos::Value_Range* Value_Ranges::add_range() {
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  return &range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
inline int Value_Set::item_size() const {
  return item_.size();
}
inline void Value_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Value_Set::item(int index) const {
  return item_.Get(index);
}
inline ::std::string* Value_Set::mutable_item(int index) {
  return item_.Mutable(index);
}
inline void Value_Set::set_item(int index, const ::std::string& value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Set::add_item() {
  return item_.Add();
}
inline void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
inline bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Text::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Value_Text::value() const {
  return *value_;
}
inline void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Text::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Value_Text::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Value::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Value::set_type(::mesos::Value_Type value) {
  GOOGLE_DCHECK(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 2;
inline bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Value::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Value::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}

// optional .mesos.Value.Ranges ranges = 3;
inline bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Value::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Value::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}

// optional .mesos.Value.Set set = 4;
inline bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_set() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Value::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Value::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}

// optional .mesos.Value.Text text = 5;
inline bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Value::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Value::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Attribute

// required string name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  return *name_;
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Attribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .mesos.Value.Type type = 2;
inline bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Attribute::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Attribute::set_type(::mesos::Value_Type value) {
  GOOGLE_DCHECK(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Attribute::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Attribute::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Attribute::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Attribute::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}

// optional .mesos.Value.Set set = 6;
inline bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attribute::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Attribute::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Attribute::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}

// optional .mesos.Value.Text text = 5;
inline bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attribute::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Attribute::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Attribute::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Resource

// required string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  return *name_;
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Resource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .mesos.Value.Type type = 2;
inline bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Resource::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Resource::set_type(::mesos::Value_Type value) {
  GOOGLE_DCHECK(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Resource::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Resource::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Resource::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Resource::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}

// optional .mesos.Value.Set set = 5;
inline bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Resource::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Resource::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResourceStatistics

// required double timestamp = 1;
inline bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ResourceStatistics::timestamp() const {
  return timestamp_;
}
inline void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double cpus_user_time_secs = 2;
inline bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
inline double ResourceStatistics::cpus_user_time_secs() const {
  return cpus_user_time_secs_;
}
inline void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
}

// optional double cpus_system_time_secs = 3;
inline bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
inline double ResourceStatistics::cpus_system_time_secs() const {
  return cpus_system_time_secs_;
}
inline void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
}

// required double cpus_limit = 4;
inline bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
inline double ResourceStatistics::cpus_limit() const {
  return cpus_limit_;
}
inline void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
}

// optional uint64 mem_rss_bytes = 5;
inline bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  return mem_rss_bytes_;
}
inline void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
}

// optional uint64 mem_limit_bytes = 6;
inline bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  return mem_limit_bytes_;
}
inline void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
}

// -------------------------------------------------------------------

// ResourceUsage

// required .mesos.SlaveID slave_id = 1;
inline bool ResourceUsage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ResourceUsage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ResourceUsage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ResourceUsage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}

// optional .mesos.ExecutorID executor_id = 3;
inline bool ResourceUsage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ResourceUsage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}

// optional string executor_name = 4;
inline bool ResourceUsage::has_executor_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceUsage::set_has_executor_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceUsage::clear_has_executor_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceUsage::clear_executor_name() {
  if (executor_name_ != &::google::protobuf::internal::kEmptyString) {
    executor_name_->clear();
  }
  clear_has_executor_name();
}
inline const ::std::string& ResourceUsage::executor_name() const {
  return *executor_name_;
}
inline void ResourceUsage::set_executor_name(const ::std::string& value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value, size_t size) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceUsage::mutable_executor_name() {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  return executor_name_;
}
inline ::std::string* ResourceUsage::release_executor_name() {
  clear_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executor_name_;
    executor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .mesos.TaskID task_id = 5;
inline bool ResourceUsage::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceUsage::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceUsage::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceUsage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& ResourceUsage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* ResourceUsage::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* ResourceUsage::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}

// optional .mesos.ResourceStatistics statistics = 6;
inline bool ResourceUsage::has_statistics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceUsage::set_has_statistics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceUsage::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceUsage::clear_statistics() {
  if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
  clear_has_statistics();
}
inline const ::mesos::ResourceStatistics& ResourceUsage::statistics() const {
  return statistics_ != NULL ? *statistics_ : *default_instance_->statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) statistics_ = new ::mesos::ResourceStatistics;
  return statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::release_statistics() {
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Request

// optional .mesos.SlaveID slave_id = 1;
inline bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Request::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Request::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}

// repeated .mesos.Resource resources = 2;
inline int Request::resources_size() const {
  return resources_.size();
}
inline void Request::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Request::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Request::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Request::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& Offer::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  return id_;
}
inline ::mesos::OfferID* Offer::release_id() {
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Offer::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Offer::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Offer::hostname() const {
  return *hostname_;
}
inline void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Offer::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 7;
inline int Offer::attributes_size() const {
  return attributes_.size();
}
inline void Offer::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& Offer::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* Offer::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* Offer::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  return &attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  return executor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  return executor_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  return &executor_ids_;
}

// -------------------------------------------------------------------

// TaskInfo

// required string name = 1;
inline bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskInfo::name() const {
  return *name_;
}
inline void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .mesos.TaskID task_id = 2;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskInfo::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskInfo::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskInfo::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}

// repeated .mesos.Resource resources = 4;
inline int TaskInfo::resources_size() const {
  return resources_.size();
}
inline void TaskInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  return &resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  return executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::release_executor() {
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}

// optional .mesos.CommandInfo command = 7;
inline bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& TaskInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* TaskInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}

// optional bytes data = 6;
inline bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskInfo::data() const {
  return *data_;
}
inline void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskStatus::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline mesos::TaskState TaskStatus::state() const {
  return static_cast< mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(mesos::TaskState value) {
  GOOGLE_DCHECK(mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TaskStatus::message() const {
  return *message_;
}
inline void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* TaskStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskStatus::data() const {
  return *data_;
}
inline void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskStatus::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1 [default = 5];
inline bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
inline double Filters::refuse_seconds() const {
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
}

// -------------------------------------------------------------------

// Environment_Variable

// required string name = 1;
inline bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Environment_Variable::name() const {
  return *name_;
}
inline void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Environment_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Environment_Variable::value() const {
  return *value_;
}
inline void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Environment_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
inline int Environment::variables_size() const {
  return variables_.size();
}
inline void Environment::clear_variables() {
  variables_.Clear();
}
inline const ::mesos::Environment_Variable& Environment::variables(int index) const {
  return variables_.Get(index);
}
inline ::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::mesos::Environment_Variable* Environment::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  return &variables_;
}

// -------------------------------------------------------------------

// Parameter

// required string key = 1;
inline bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Parameter::key() const {
  return *key_;
}
inline void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Parameter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  return *value_;
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Parameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Parameters

// repeated .mesos.Parameter parameter = 1;
inline int Parameters::parameter_size() const {
  return parameter_.size();
}
inline void Parameters::clear_parameter() {
  parameter_.Clear();
}
inline const ::mesos::Parameter& Parameters::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::mesos::Parameter* Parameters::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::mesos::Parameter* Parameters::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  return &parameter_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Value_Type>() {
  return ::mesos::Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< mesos::Status>() {
  return mesos::Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< mesos::TaskState>() {
  return mesos::TaskState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2eproto__INCLUDED
